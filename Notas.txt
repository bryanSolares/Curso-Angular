Versionamiento y significado
7.0.2

2=Parches, retrocompatible, arreglo de errores
0=Actualización menor, agrega funcionalidades, retro compatible 
7=Versión mayor, puede ser o no retro compatible


Video 1.10***************************************************************
compilación de codigo typescript a js => tsc nombrearchivo.ts
para generar archivo de configuración ts => tsc --init
noImplicitAny => nada declarado como any
tsc -w => entra en modo observador para compilación automática
encabezado de tsconfig despues de llaves colocar para excluir directorios para compilación => exclude = ["nombredirectorio"]

Video 1.16***************************************************************
Primero son los argumentos obligatorios, opcionales por último por defecto.

Video 2.19***************************************************************
Promesas= código que se ejecuta y que permite no bloquear el código de mi aplicación
Las promesas no se pueden traducir a ES5

Video 2.23***************************************************************
Es convesión que las clases tengan la primera letra capitalizada

Video 2.26***************************************************************
Añadido que se coloca antes de la definición de la clase
Permite añadir funcionalidad a la clase, se inicia con @nombredecorador

Video 3.35***************************************************************
Los componentes, pequeñas clases que cumplen una tarea en especifico:
1.Menu de navegacion
2.Barra lateral
3.Subbloques
4.Pie de aplicación
Son clases normales que tiene un decorador en especifico

DIRECTIVAS ESTRUCTURALES:
Le dicen al html que debe hacer:
*ngIf
*ngFor

Video 3.38***************************************************************
Para crear un proyecto => ng new nombreaplicacion
Para correr aplicacion en puerto por defecto 4201 => ng serve -o

Video 3.39***************************************************************
Estructura de un proyecto angular
e2e = carpeta destinada al manejor de prueba de extremo a extremo
node_modules = modulos de nodejs, no se debe subir a un repositorio
src = se encuentra la aplicación angular
    app = archivos de nuestra aplicación
        component.ts = primer componenete que la aplicación cargará
        component.html = html del componente en especifico
        component.css = css del componente en especifico
        component.spec.ts = para pruebas automáticas
        module.ts = contenedor de módulos y decoradores especiales
    assents = donde se coloca recursos estaticos
        .gitkeep = sirve para subir la carpeta a git
    enviroments = contenedor de variables de ambiente
        environment.ts = variables de ambiente de desarrollo
        environment.prod.ts = variables de ambiente de produccion
    browserslist = para ajustar css o mejor soporte de css
    index.html = renderiza la aplicación aquí
    main.ts = configuracion inicial para ambiente de aplicacion web
    polyfills.ts = para configuración de navegadores viejos
    styles.css = estilos globales para la aplicación
karma.conf.js = pruebas de karma
.editorconfig = configuraciones del editor
.gitignore = archivos que ignora carpetas para commit
angular.json = archivo que le dice a angular como es nuestra aplicacion y como funciona
browserslist = configuración para soporte de navegadores
package-lock = como le dice a node como fue creado el package.json
package.json = archivo importante. 
README.md = explica como funciona la aplicacion
tsconfig.json = le dice a typescript como trabajar
tslint.json = forzará a escribir un código más limpio de ts

Video 3.40***************************************************************
Como convención cuando se crea un componente despues del nombre sería= nombre.component.ts
Esto indentifica el archivo de manera entendible
Para utilizar un componente se debe exportar la clase y en el app.module.ts se debe agregar a ***********declarations***************
Para convertir una clase componente es necesario agregar el decorador Component de @angular/core

Video 3.42***************************************************************
Para crear componentes:
ng g c ubicacion/nombrecomponenete

Video 3.44***************************************************************
DIRECTIVAS
*ngFor
*ngIf

Video 4.51 ***************************************************************
Son tres formas las cuales se pueden utilizar para instalar bootstrap
1. Direcciones de la web
2. Descargar los archivos
3. Instalar desde npm <- aquí se debe modificar el archivo angular.json
 La desventaja de hacer en la forma tres, es que las librerias forman parte del bundle y la aplicación pesaría más.
                         "styles": [
                            "src/styles.css",
                            "./node_modules/bootstrap/dist/css/bootstrap.min.css"
                        ],
                        "scripts": [
                            "./node_modules/jquery/dist/jquery.slim.min.js",
                            "./node_modules/popper.js/dist/umd/popper.min.js",
                            "./node_modules/bootstrap/dist/js/bootstrap.min.js"
                        ]

Video 4.52 ***************************************************************
para crear un componente sin estilos: ng g c nombrecomponente -is

Video 4.53 ***************************************************************
para crear rutas es necesario seguir la estructura, en src:

import { RouterModule, Routes } from '@angular/router';
import { HomeComponent } from './components/home/home.component';

const APP_ROUTES: Routes = [
  { path: 'home', component:  HomeComponent},
  { path: '**', pathMatch: 'full', redirectTo: '' },
];

export const APP_ROUTING = RouterModule.forRoot(APP_ROUTES,{useHash:true});

luego se importa la constantes en app.module.ts y se coloca en la sección de imports

// Rutas
import { APP_ROUTING } from './app.module.routes';
imports: [
    BrowserModule,
    APP_ROUTING
        ],

Cuando se utiliza la opción de userHash:true, no es necesaria la línea en el html principal: -> <base href="/">
de lo contrario es obligatorio

Video 4.54 ***************************************************************
Para hacer una navegación entre paginas se debe implementas [routerLink] en lugar de a href, debo a que es una pagína estática
[routerLink]="['ruta']" <- arreglo de direcciones

routerLinkActive="active" <- para indicar que una ruta tiene el foco o está activa

Video 4.56 ***************************************************************
SERVICIOS:
Bridar información a quién lo necesite
Realizar peticiones CRUD
Mantener la data de forma persistente
Servir como recurso re-utilizable para nuestra aplicación

Video 4.57 ***************************************************************
Como estándar para nombrar un archivo de servicio es:
nombre.service.ts

Para crear un servicio se debe colocar a la clase un decorador -> Injectable = @angular/core

Para que la aplicación entienda que tiene un servicio para usar se debe colocar el servicio en app.module.ts
Se debe colocar en sección de providers
providers: [
    HeroesService
            ]
Para utilizarlo en el componente, se debe importar en éste y luego instanciarlo en el constructor


Video 4.59 ***************************************************************
Para hacer un direccionamiento a una pagina nueva se puede hacer de dos formas:
1. con la etiqueta a y usando [routerLink]="['/ruta',parametro]"
2. mediante un método en un botón button (click)="nombremetodo(parametro)" -> aquí usar en método router.navigate(['/ruta',parametro])

Video 4.60 ***************************************************************
Para recibir los parametros enviados mediante url, se hace con la clase ActivatedRoute en @angular/router
con una instancia de éste clase se puede recibir el el parámetro bajo una subscripcion

this.activetedRoute.params.subscribe(params => {
      console.log(params['nombreparametro']);
    })

Video 4.63 ***************************************************************
PIPES:
Transforman la data en el template, ayudarán a que la data se vea mejor
*currency
*date
*uppercase
*json
*limitTo
*lowercase
*asyc
*decimal
*percet

Un ejemplo para use de pipes en el html:
<h1 class="animated fadeIn"> {{heroe.nombre | uppercase}} <small>({{heroe.aparicion | date:'y'}})</small> </h1>

Video 4.64 ***************************************************************
Para agregar un evento sobre cualquier elemento HTML se procede:
(keyup.enter)="nombrefuncion(buscarTexto.value)"
(click)="nombrefuncion(buscarTexto.value)"


Video 4.68 ***************************************************************
Para genera un componente sin el archivo de pruebas:
ng g c nombrecomponenete --spec=false
Para enviar información de un componente padre a un hijo se usa el decorador @Input() en el componente donde se recibirá la información, en el componenete se debe colocar éste decorador a los atributos que recibiran el valor del padre.
  @Input() heroe: any = {};
  @Input() id: number;

Para enviar los datos desde el padre:
<app-heroe-tarjeta [heroe]="heroe" [id]="heroe.id" *ngFor="let heroe of heroes"></app-heroe-tarjeta>
entre llaves cuadradas se coloca el nombre de la variable que está recibirá el valor y dentro de las comillas lo que se envia.


Video 4.69 ***************************************************************
Para utilizar métodos del padre desde hijo es necesario que desde el hijo que proceda a hacer una salida (@Output decorador), acompañado de un EventEmitter que será el transmisor del evento.

En el componenete hijo se debe instanciar un EventEmmiter que será el emisor desde el padre. En el método donde que se utilizará para activar el emisor se emitirá el dato hacía el padre. En el padre se asimilará un evento que será el escuchador con el mismo nombre del Emitter en lugar de click ((click) = (nombre eventemitter)), luego de ésto éste escuchador será el que dispare la función propia del padre. El resultado sería:

HIJO:
@Output() heroeSeleccionado: EventEmitter<number>;

constructor(private router: Router) 
{
    this.heroeSeleccionado = new EventEmitter();
}

<button (click)="verHeroe()">

verHeroe() 
{
    this.heroeSeleccionado.emit(this.id);
}

PADRE:
 <app-heroe-tarjeta (heroeSeleccionado)="verHeroe($event)"  

verHeroe(indice: number)
{
    this.router.navigate(['/heroe', indice]);
}



SECCION 5 ***************************************************************
Manejo de pipes (Tuberias |): sirven para transformar data en el html de manera visual

Slice = permite cortar, éste requiere un parámetro por lo menos


para configuración de idioma de acuerdo al pais donde se necesite (por defecto angular se configura en inglés)
ng add @angular/localize
import { registerLocaleData  } from "@angular/common";
import localEs from "@angular/common/locales/es";

registerLocaleData(localEs);
 providers: [
    {
      provide: LOCALE_ID,
      useValue: 'es'
    }

Para crear un pipe personalizado con angular cli: 
ng g p nombrepipe

Colocará un decorador @Pipe = @angular/core

Para cargar recursos que son externos y el DOM los cataloga como inseguros de debe crear un pipe
import { Pipe, PipeTransform } from '@angular/core';
import { DomSanitizer, SafeResourceUrl } from '@angular/platform-browser';

@Pipe({
  name: 'domseguro'
})
export class DomseguroPipe implements PipeTransform {

  constructor(private domSanitizer: DomSanitizer){}

  transform(value: string, ...args: unknown[]): SafeResourceUrl {
    return this.domSanitizer.bypassSecurityTrustResourceUrl(value);
  }

}

<iframe
      width="560"
      height="315"
      [src]="videoUrl | domseguro"
      frameborder="0"
      allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
      allowfullscreen
    ></iframe>

 

SECCION 6 ***************************************************************
Para utilizar la funcionalidad de peticiones es necesario agregar a los imports en app.module.ts el HttpClientModule de @angular/common/http
y luego en donde se quiere agregar la funcionalidad de peticiones http se importa la característa de la anterior importación: HttpClient de @angular/common/http
-------------------------------------------------------------------------------------
Cuando en un servicio se encuentre el decorador:
@Injectable({
  providedIn: 'root'
})
significará que no es necesario la importación en la sección de providers en el app.module.ts

-------------------------------------------------------------------------------------
Para añadir encabezados (headers) a una petición http se hace:
import { HttpHeaders } from '@angular/common/http';
const headers = new HttpHeaders({
      Authorization:
        'Bearer BQBjnRXm4jN9yTvM4mJdK9zk8B4CJHrk-h2MMlmOfgdv3Y25GXEeJZwNcHlb1FPxx7zKqo0E_wpD75_o5CQ',
    });

this.http
      .get('https://api.spotify.com/v1/browse/new-releases', {headers})
      .subscribe((data) => console.log(data));













